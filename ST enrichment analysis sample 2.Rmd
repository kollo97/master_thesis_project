---
title: "LCA_sliding_window_BH001_sc_short"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "reports")})
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    dev: 'CairoPNG'
date: "`r Sys.Date()`"
---

Load libraries:

```{r, message=FALSE}
library(STutility)
library(dplyr)
library(tidyverse)
library(data.table)
library(reshape2)
library(readxl)
library(ggplot2)
library(Seurat)
library(RColorBrewer)
```

```{r setup, include=FALSE}
library(knitr)

# which plots to print:
violin <- F
lineplots <- T
p.plots <- T
gridarrange <- F


# plot setups
# violin.w <- 12 
# violin.h <- 9
# 
# working with 4K monitor?
big_screen <- F

# global chunk settings
opts_chunk$set(echo = TRUE)
opts_chunk$set(dev = "CairoPNG")
opts_chunk$set(error = TRUE)# when FALSE, interrupt in case of errors                
opts_chunk$set(out.width = "100%")
opts_chunk$set(out.height = "100%")

#<<featureplot>>
opts_hooks$set(
# eval
  eval = function(options) {
    raw.code <- knit_code$get(opts_current$get()$label) 
    raw.code <- paste(raw.code, collapse = "")
    if (grepl("p.val.nullset|p_value|p.val|top.genetic.genes|p.value|<<calculate p-value>>|<<p-val-plot>>|<<load_p_val_nullset>>|<<addmodulescore_top_genes>>|<<spatial_p_plot>>", raw.code)) {
      options$eval = p.plots
      }
    if (grepl("<<line plot>>|line.plot.setup", raw.code)){
      options$eval = lineplots
      }
    if (grepl("VlnPlot|geom_violin", raw.code)){
      options$eval = violin
      }
    if (grepl("<<featureplot>>", raw.code)){
      options$eval = gridarrange
      }
  options
  })

opts_hooks$set(
# include
  include = function(options) {
    raw.code <- knit_code$get(opts_current$get()$label) 
    raw.code <- paste(raw.code, collapse = "")
    if (grepl("p.val.nullset|p_value|p.val|top.genetic.genes|p.value|<<calculate p-value>>|<<p-val-plot>>|<<load_p_val_nullset>>|<<addmodulescore_top_genes>>|<<spatial_p_plot>>", raw.code)) {
      options$include = p.plots
      }
    if (grepl("<<line plot>>|line.plot.setup", raw.code)){
      options$include = lineplots
      }
    if (grepl("VlnPlot|geom_violin", raw.code)){
      options$include = violin
      }
    if (grepl("<<featureplot>>", raw.code)){
      options$include  = gridarrange
    }
    
  options
  })

opts_hooks$set(
# fig.width
  fig.width = function(options) {
    raw.code <- knit_code$get(opts_current$get()$label) 
    raw.code <- paste(raw.code, collapse = "")
    if (grepl("p.plot.setup", raw.code)) {
        options$fig.width = 12
    }
    if (grepl("<<spatial_p_plot>>", raw.code)) {
        options$fig.width = 5
    }
    if (grepl("line plot|line.plot.setup", raw.code)){
        options$fig.width = 30
        }
    if (grepl("VlnPlot|geom_violin", raw.code)){
        options$fig.width = 12 
      }
    if (grepl("<<featureplot>>", raw.code)){
      options$fig.width  = 20
      }

    options
  })
opts_hooks$set(
# fig.height
  fig.height = function(options) {
    raw.code <- knit_code$get(opts_current$get()$label) 
    raw.code <- paste(raw.code, collapse = "")
    if (grepl("p.plot.setup", raw.code)) {
        options$fig.height = 9
    }
    if (grepl("<<spatial_p_plot>>", raw.code)) {
        options$fig.height = 4
    }
    if (grepl("line plot|line.plot.setup", raw.code)){
      options$fig.height = 30
      }
    if (grepl("VlnPlot|geom_violin", raw.code)){
      options$fig.height = 9
      }
    if (grepl("<<featureplot>>", raw.code)){
      options$fig.height  = 15
    }
    
    options
  }
)

opts_hooks$set(fig.height = function(options) {
  if (big_screen == T) {
    options$fig.height = options$fig.height*1.5
  }
  options
})


```


# Load ST data:

```{r}
infoTable <- read.csv("livercellatlas_data/visium/mouse/infoTable.csv", header = TRUE, sep =",")
sample <- "BH001"
sample.path <- paste("livercellatlas_data/visium/mouse", infoTable[infoTable$short_file_name == sample,]$geo_accession, sep = "/")
se <-  readRDS(file = paste0(sample.path, "/preprocessed_se_BH001.rds"))
DefaultAssay(se) <- "SCT"
```

FeatureOverlay

```{r, fig.width=8, fig.height=4}

spot_alpha = 0.2
point.size = 1.2

FeatureOverlay(se, 
               features = c("nCount_RNA","nFeature_RNA"),
               pt.alpha = spot_alpha,
               pt.size = point.size,
               add.alpha=T,
               ncols = 2,
               cols = c("black", "darkblue", "cyan", "yellow", "red", "darkred"))
```

## load zone and annotated seurat_clusterss from "spatial_structures" file

```{r, load clusters and zones}
res <- 0.8
res.columns <- colnames(se[[]])[startsWith(colnames(se[[]]), "SCT_snn_res.")]
se$seurat_clusters <-as.factor(se[[]][,paste0("SCT_snn_res.", res)]) #make the desired resolution the "seurat-clusters" metadata for now
#can you use setident instead? Nevermind



```

```{r}
library(viridis)
n <- 18
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
col_vector[6] <- "white"
col_vector[8] <- "lightpink"
# col_vector2 <- c("darkred","orange","lightblue","darkblue",col_vector)
n <- length(unique(se$seurat_clusters))
col_vector2 <- viridis(n = n)
se <- SetIdent(se, value="seurat_clusters")
```

## Cluster Feature Overlay

```{r,fig.width=10, fig.height=4}
# col_vector2 <- c("orange","lightblue","red","darkblue")

p2 <- FeatureOverlay(object = se, features = "seurat_clusters", pt.alpha = 0.6, pt.size = point.size, cols = col_vector2, pt.border = FALSE)
p3 <- FeatureOverlay(object = se, features = "Cyp2e1", pt.alpha = 0.6, pt.size = point.size, cols = col_vector2, pt.border = FALSE)


p2|p3
```


```{r,fig.width=5, fig.height=4}
VlnPlot(se, features = "Cyp2e1")+
  geom_boxplot(width=0.4)
```

# calculate own zonation
```{r calculate own zonation}
zonation.markers <- list(central_markers = c("Glul", "Oat"," Slc1a2","Cyp2e1", "Cyp2a5"),
                          portal_markers = c("Sds","Cyp2f2","Hal","Hsd17b13","Aldh1b1"))

se <- AddModuleScore(se, features = zonation.markers, name = names(zonation.markers))
```

```{r calculate own zonation cont}
meta.data <- se[[]]

# Define custom quantile values
quantiles_4 <- c(0, seq(0.1,0.9,length.out = 3) , 1)
quantiles_6 <- c(0, seq(0.1,0.9,length.out = 5) , 1)
quantiles_9 <- c(0, seq(0.1,0.9,length.out = 8), 1) # not sure why length.out = 8 n this case, but this yields 9 clusters for BH001

meta.data <- meta.data %>%
  rename(central_markers = central_markers1,
         portal_markers = portal_markers2) %>%
  mutate(p_4 = findInterval(portal_markers, quantiles_4, all.inside = TRUE),
         p_6 = findInterval(portal_markers, quantiles_6, all.inside = TRUE),
         p_9 = findInterval(portal_markers, quantiles_9, all.inside = TRUE),
         c_4 = findInterval(central_markers, quantiles_4, all.inside = TRUE),
         c_6 = findInterval(central_markers, quantiles_6, all.inside = TRUE),
         c_9 = findInterval(central_markers, quantiles_9, all.inside = TRUE))
unique(meta.data$c_9)
```
```{r,fig.width=5, fig.height=4}
DefaultAssay(se)
se <- SetIdent(se, value = "p_4")
VlnPlot(se, features = "Cyp2f2")+
  geom_boxplot(width=0.4)
```

```{r}
findInterval(meta.data$central_markers, quantiles_9, all.inside = TRUE)
```


```{r}

table(meta.data$p_4)

table(meta.data$c_4)
```

```{r calculate own zonation2}
meta.data <- se[[]]

meta.data <- meta.data %>%
  rename(central_markers = central_markers1,
         portal_markers = portal_markers2) %>%
  mutate(p_4 = ntile(portal_markers, 4),
         p_6 = ntile(portal_markers, 6),
         p_9 = ntile(portal_markers, 9),
         c_4 = ntile(central_markers, 4),
         c_6 = ntile(central_markers, 6),
         c_9 = ntile(central_markers, 9)
         )


zonation.columns <- meta.data %>%
  select(starts_with("p_"), starts_with("c_")) %>%
  colnames()

meta.data <- meta.data %>%
  mutate_at(zonation.columns, as.factor)

se@meta.data[,zonation.columns] <- NULL

se <- AddMetaData(se, meta.data[,zonation.columns])

# write.table(meta.data, 
#             file = paste0(sample.path, "/self_made_zonation_clusters.tsv"),
#             sep = "\t",
#             row.names = T,
#             col.names = T)
```

```{r,fig.width=15, fig.height=5}
pt.size <- 1.5
length(unique(se[[]][,zonation.columns[1]]))
p1 <- FeatureOverlay(object = se, features = zonation.columns[1], pt.alpha = 0.6, pt.size = pt.size, cols = viridis(n = length(unique(se[[]][,zonation.columns[1]]))), pt.border = FALSE)
p2 <- FeatureOverlay(object = se, features = zonation.columns[2], pt.alpha = 0.6, pt.size = pt.size, cols = viridis(n = length(unique(se[[]][,zonation.columns[2]]))), pt.border = FALSE)
p3 <- FeatureOverlay(object = se, features = zonation.columns[3], pt.alpha = 0.6, pt.size = pt.size, cols = viridis(n = length(unique(se[[]][,zonation.columns[3]]))), pt.border = FALSE)
p1|p2|p3


p1 <- FeatureOverlay(object = se, features = zonation.columns[4], pt.alpha = 0.6, pt.size = pt.size, cols = viridis(length(unique(se[[]][,zonation.columns[1]]))), pt.border = FALSE)
p2 <- FeatureOverlay(object = se, features = zonation.columns[5], pt.alpha = 0.6, pt.size = pt.size, cols = viridis(length(unique(se[[]][,zonation.columns[2]]))), pt.border = FALSE)
p3 <- FeatureOverlay(object = se, features = zonation.columns[6], pt.alpha = 0.6, pt.size = pt.size, cols = viridis(length(unique(se[[]][,zonation.columns[3]]))), pt.border = FALSE)
p1|p2|p3
```

```{r,fig.width=6, fig.height=4, code_folding = 'hide' }
library(ggpubr)
# meta.data %>%
#   ggplot(aes(x = as.numeric(p_9), y = as.numeric(c_9), fill = central_markers, color = central_markers))+
#   geom_point(position = "jitter")
  # geom_boxplot()
meta.data %>%
  ggplot(aes(x = central_markers, y = portal_markers))+
  geom_point(color = "black", fill = "darkblue", shape = 21, alpha = 0.7)+
  geom_smooth(method = "lm", colour = "red", linewidth = 1) +
  theme_minimal() +
  stat_cor(method = "pearson", label.x = 1) +
  labs(x = "AddModuleScore\n central marker genes", 
       y = "AddModuleScore\n portal marker genes")
  # geom_boxplot()
meta.data %>%
  ggplot(aes(x = c_4, y = seurat_clusters))+
  geom_point(position = "jitter", color = "black", fill = "darkblue", shape = 21, alpha = 0.7)+
  geom_smooth(method = "lm", colour = "red", linewidth = 1) +
  theme_minimal() +
  stat_cor(method = "pearson", label.x = 1) +
  labs(x = "zones based on addmodulescore quartiles \n from central marker genes", 
       y = "seurat_clusters based on FindClusters()")

meta.data %>%
  ggplot(aes(x = p_4, y = seurat_clusters))+
  geom_point(position = "jitter", color = "black", fill = "darkblue", shape = 21, alpha = 0.7)+
  geom_smooth(method = "lm", colour = "red", linewidth = 1) +
  theme_minimal() +
  stat_cor(method = "pearson", label.x = 1) +
  labs(x = "zones based on addmodulescore quartiles \n from portal marker genes", 
       y = "seurat_clusters based on FindClusters()")

meta.data %>%
  ggplot(aes(x = p_6, y = seurat_clusters))+
  geom_point(position = "jitter", color = "black", fill = "darkblue", shape = 21, alpha = 0.7)+
  geom_smooth(method = "lm", colour = "red", linewidth = 1) +
  theme_minimal() +
  stat_cor(method = "pearson", label.x = 1) +
  labs(x = "zones based on addmodulescore quartiles \n from portal marker genes", 
       y = "seurat_clusters based on FindClusters()")

```

# load other data

## load window meta data

from AddModuleScore (from before)

```{r}
meta.data <- read.csv(file =  paste0(sample.path,"/", sample,"_sliding_window_meta_data.tsv"),
                      sep = "\t")
meta.data <- meta.data %>%
  dplyr::select(contains("_rank_"))
meta.data <- meta.data[rownames(meta.data) %in% rownames(se[[]]),] # i forgot to subset the mitochondrial genes before doing the sliding window (I think) so I will subset the sliding window data now
```


```{r}
se <- AddMetaData(se, meta.data) # combine both dataframes on the rownames
```

```{r}
meta.data %>%
  select(contains("_rank_")) %>%
  colnames() %>%
  gsub("_rank_.*","",.)%>%
  unique()

```

```{r, make summary df of the windows}
library("psych")
#here you can decide whether you wanna summarise by cluster or by zone! 
#zone or seurat_clusters
summarise.on <- "seurat_clusters"
meta.data <- se[[]]

summary.meta.clusters <- meta.data %>%
  dplyr::select(all_of(summarise.on), contains("_rank_"))

summary.meta.clusters <- describeBy(summary.meta.clusters, group = summary.meta.clusters[, summarise.on], quant = c(.05, .95)) 

summary.meta.clusters <- lapply(summary.meta.clusters, function(x) as.data.frame(x))


summary.meta.clusters <- map(summary.meta.clusters, ~.x %>%
                               rownames_to_column(., var = "window"))
summary.meta.clusters <- bind_rows(summary.meta.clusters, .id = summarise.on)
summary.meta.clusters <- summary.meta.clusters[-1,]
rownames(summary.meta.clusters) <- NULL
head(summary.meta.clusters)
```

```{r}
genetic.summary.meta.clusters <- summary.meta.clusters %>%
  filter(window %like% "genetic")
drug.summary.meta.clusters <- summary.meta.clusters %>%
  filter(window %like% "drug")

```

## load NULL set data

```{r, load NULL gene set data}

raw.NULL.set <- fread(list.files(sample.path, pattern = paste0("se_null_set_meta_data", sample,"_g50"), full.names=T ), sep = "\t") # for the line_plots ==> i.e. equivalent to "g50" 
gxx <- sub(".*_","",list.files(sample.path, pattern = paste0("se_null_set_meta_data", sample,"_g50")))
gxx <- sub(".tsv.*","",gxx)
colnames(raw.NULL.set)[1] <- "barcode"

raw.NULL.set$seurat_clusters <- NULL

raw.NULL.set <- raw.NULL.set %>%
  left_join(meta.data %>%
              rownames_to_column(var = "barcode")%>%
              select(all_of(summarise.on), barcode),
            by = "barcode")

raw.NULL.set <- raw.NULL.set %>%
  group_by(across(all_of(summarise.on)))%>%
  summarise(across(contains("NULL_gene_set_"), median))%>%
  column_to_rownames(summarise.on) %>%
  t() %>%
  as.data.frame()

NULL.set.data <- describe(raw.NULL.set, quant = c(.05, .95)) %>%
  as.data.frame %>%
  rownames_to_column(var = summarise.on) #summarized perm.matrix ==> median of all permutations


stacked.NULL.data <- stack(raw.NULL.set)
colnames(stacked.NULL.data) <- c("addmodulescore",summarise.on)
stacked.NULL.data$permutation <- rep(c(1:10000),length(unique(stacked.NULL.data[, summarise.on])))

remove(seurat_clusters)
```

## introduce empty vectors to store data in

```{r for p value calculations}
important_plots <-  list()
```

# plotting

## load OT.files

is easier to select the top genes and plot the density/p-value plot

```{r, code_folding = 'hide'}
OT.files.split <- readRDS(file = paste("OpenTargets", sample,"OT_files_split", sep = "/"))

OT.files.split.genetic <- sapply(OT.files.split, function(x) x[grep("genetic", names(x), value = T)])
names(OT.files.split.genetic) <- names(OT.files.split)
OT.files.split.genetic <- OT.files.split.genetic[sapply(OT.files.split.genetic, function(x) length(x)>0)]


OT.files.split.drug <- sapply(OT.files.split, function(x) x[grep("drug", names(x), value = T)])
names(OT.files.split.drug) <- names(OT.files.split)
OT.files.split.drug <- OT.files.split.drug[sapply(OT.files.split.drug, function(x) length(x)>0)]
OT.files.split.drug <- sapply(OT.files.split.drug, function(x) x[[1]])
```

## NAFLD {.tabset}

subset features_to_plot to specific disease for now

```{r}
disease <- "NAFLD"
features_to_plot <- se[[]] %>%
  dplyr::select(contains("_rank_")) %>%
  colnames()
features_to_plot <- features_to_plot[features_to_plot %like% disease]

```

### Violin Plots

```{r Violin Plots, eval = violin}
for (i in features_to_plot){

  plot(VlnPlot(se,
        features = i,
        ncol = 1,
        group.by = summarise.on,
        cols = col_vector2,
        pt.size = 0.1) +
  geom_boxplot(width=0.4) +
  theme(plot.title = element_text(size = 12))
  )
}

```

### grid.arrange FeaturePlot

```{r featureplot, fig.width=20, fig.height=15, eval = gridarrange}
#<<featureplot>>
library(gridExtra)
max <- 12
num_plots <- c(1:length(features_to_plot))
num_plots <- split(num_plots, ceiling(seq_along(num_plots)/max))
spot.alpha <- 0.75
point.size = 1.25

for (i in num_plots){
  plot.list <- list()
  plots <- unlist(i)
  for (j in c(1:length(plots))){
    
    plot.list[[j]] <- 
      ST.FeaturePlot(se,
               features = features_to_plot[plots[j]],
               # pt.alpha = spot_alpha,
               pt.size = point.size,
               # grid.ncol = 4,
               cols = c("black", "darkblue", "cyan", "yellow", "red", "darkred"),
               value.scale = "all"
                )
  }
  do.call(grid.arrange, c(plot.list, ncol = 4, nrow = 3))
}

```

### line plot setup

```{r, class.source = 'fold-hide'}

library(cowplot)
#boxplot on the right side
p.boxplot <- NULL.set.data %>%
  ggplot(aes(x = .data[[summarise.on]], ymin=min, lower= Q0.05, middle = median, upper = Q0.95, ymax = max)) +
  geom_boxplot(stat = "identity") +
  # ggtitle("")+
  theme_classic()+
  facet_wrap(vars(.data[[summarise.on]]), ncol = 1, scales = "free", strip.position = "left") 

line.plot.setup <- function(x){
  lwd <- 0.2
  lty <- 2
  p1 <- ggplot(x, aes(window, median, group = 1)) +
  geom_point(shape = "o", size = 2) +
  geom_line(linewidth = 0.1) +
  geom_hline(data = NULL.set.data, aes(yintercept  = min), colour = "darkred", lwd = lwd, lty = lty)+
  geom_hline(data = NULL.set.data, aes(yintercept  = max), colour = "darkred", lwd = lwd, lty = lty)+
  geom_hline(data = NULL.set.data, aes(yintercept  = median), col = "blue", lwd = lwd, lty = lty)+
  geom_hline(data = NULL.set.data, aes(yintercept  = Q0.05),color = "red", lwd = lwd, lty = lty)+
  geom_hline(data = NULL.set.data, aes(yintercept  = Q0.95), colour = "red", lwd = lwd, lty = lty)+
  xlab("Rank") +
  ylab("Score") +
  scale_x_discrete(labels = c(1:nrow(x))) +
  theme_classic()+
  facet_wrap(vars(.data[[summarise.on]]), ncol = 1, scales = "free")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        strip.background = element_blank(),
        strip.text.x = element_blank())
  
  
  combined.plot <- plot_grid(p.boxplot, p1,
                             align = "h", axis = "b", ncol = 2, rel_widths = c(1, 20)) #https://stackoverflow.com/questions/41834093/decrease-margins-between-plots-when-using-cowplot, not used but can be adjusted
  combined.plot
}
```

### line plots

```{r line plot, fig.width = 30, fig.height= 20}

genetic_features_to_plot <- summary.meta.clusters %>%
  filter(window %in% features_to_plot & window %like% "genetic") 
drug_features_to_plot <- summary.meta.clusters %>%
  filter(window %in% features_to_plot & window %like% "drug")

p <- line.plot.setup(genetic_features_to_plot) +
  ggtitle("genetic associations")

p

important_plots[[disease]][["line.plot"]] <- p


# line.plot.setup(drug_features_to_plot) +
#   ggtitle("drug associations")


```

### p value permutation

#### top genetic genes

##### select top genes

```{r}
nr.top.genetic.windows <- 10
#what was the window size:
win.size <- 50
move.by <- 10
nr.top.genes <- win.size + ((nr.top.genetic.windows-1) * move.by)
maximum <- ifelse(length(OT.files.split.genetic[[disease]])<=nr.top.genes,
                  length(OT.files.split.genetic[[disease]]),
                  nr.top.genes) %>% as.numeric()
top.genetic.genes <- OT.files.split.genetic[[disease]][1:maximum]
```

#### load correct null set for p-value calculation

==> number of genes per permutation should equal the number of top.genetic.genes (nr.top.genes)

```{r load_p_val_nullset}

p.val.nullset <- read.csv(paste0(sample.path, "/se_null_set_", sample,"_g", maximum,"_res",res,".tsv"), sep = "\t")
# 
# [] delete the "res" stuff when analysing the zones?
colnames(p.val.nullset) <- gsub("X","", colnames(p.val.nullset))
stacked.p.val.nullset <- stack(p.val.nullset)
colnames(stacked.p.val.nullset) <- c("addmodulescore","seurat_clusters")
stacked.p.val.nullset$permutation <- rep(c(1:10000),length(unique(stacked.p.val.nullset$seurat_clusters)))
```

##### addmodulescore for top genes

```{r addmodulescore_top_genes}
top.genetic.genes <- AddModuleScore(se, features = list(top.genetic.genes), name = paste0(disease, "_top_genetic_genes")) %>%
  .@meta.data %>%
  select(contains(paste0(disease, "_top_genetic_genes")), seurat_clusters)

top.genetic.genes <- top.genetic.genes %>%
  group_by(seurat_clusters)%>%
  summarise(across(where(is.numeric), median))%>% 
  column_to_rownames("seurat_clusters") %>%
  t() %>%
  as.data.frame()%>%
  stack()
colnames(top.genetic.genes) <- c("median","seurat_clusters")

```

##### calculate p-value

```{r calculate p-value}
p.value <- imap(p.val.nullset, function(x, idx){
  print(idx) #this is the column name
  median.to.compare.against <-  top.genetic.genes[top.genetic.genes$seurat_clusters == idx, "median"]
  print(paste0("median: ", median.to.compare.against))
  length(x[x>=median.to.compare.against]) #for each column/seurat_clusters in the raw.NULL.set, subset the column to those rows that have a higher median than the median of the top (70) genes for each cluster
})



p.value <- sapply(p.value, function(x) (x+1)/(10000+1)) 
# calculate the fraction of the medians of the  10000 permutations that are higher than the median of the top.genes median 
# think about p-value definition:
# “the probability of obtaining test results at least as extreme as the results actually observed, under the assumption that the null hypothesis is correct.” 
p.value.adj <- p.adjust(p.value, method = c("bonferroni")) #, n=length(unique(top.genetic.genes$seurat_clusters))
p.value.adj <- data.frame("p.value.adjusted" = p.value.adj, "p.val" = p.value ,"seurat_clusters" = as.factor(names(p.value.adj)))

top.genetic.genes <- top.genetic.genes %>%
left_join(p.value.adj) %>%
  arrange(p.value.adjusted)%>%
  mutate(significant = ifelse(p.value.adjusted<0.05,T,F),
         log10.p.adj = -log10(p.value.adjusted),
         log10.p = -log10(p.val),
         )
```


##### p-val plot setup

```{r p-val plot setup}
p.plot.setup <- function(top.genes.df){
  # adj_p_value <- ifelse(top.genes.df$p.value.adjusted<0.5,
  #                       top.genes.df$p.value.adjusted,
  #                       1-top.genes.df$p.value.adjusted)
  top.genes.df <- top.genes.df %>%
  arrange(p.value.adjusted)
  p <- ggplot(stacked.p.val.nullset, aes(x=addmodulescore)) +
  geom_density(fill = "#69b3a2",
               alpha = 0.8)+
  geom_vline(data = top.genes.df, aes(xintercept = median, color = significant),
             size = 1, show.legend = T) +
  scale_color_manual(values = c("yellow","red"), breaks = c("FALSE", "TRUE"))+
  geom_label(data = top.genes.df,
             aes(x=median+0.1, y = 8),
             label = paste0("adjusted p-value \n",
                      formatC(top.genes.df$p.value.adjusted,
                           format = "e", digits = 2)),
             size = 2) +
  xlab("Median score NULL gene set")+
  ylab("Density")
  
p +
  facet_wrap(~factor(seurat_clusters, levels = top.genes.df$seurat_clusters ))+
  theme_classic()
}
```

### p-value density plot

```{r p-val-plot, fig.height=9, fig.width=12}
p.plot.setup(top.genetic.genes)
important_plots[[disease]][["p.plot"]] <- p.plot.setup(top.genetic.genes)
saveRDS(important_plots$NAFLD$line.plot, "test_dens_plot.rds")
```


purple line is the median addmodulescore of the top.genes in each cluster

### spatial p-val plot

```{r spatial_p_plot, fig.width=5, fig.height=4}
#spatial_p_plot
library(viridis)
p.vals <- se[[]]
p.vals<- p.vals %>%
  left_join(top.genetic.genes) %>%
  select(!contains("rank"))
rownames(p.vals) <- rownames(se[[]])
p.se <- se 
p.se <- AddMetaData(p.se, p.vals)
p <- ST.FeaturePlot(object = p.se,
              features = "log10.p",
              pt.size = 1,
              cols = col_vector2
              )+
  labs(fill="-log10(p-value)", title = "") 
p
# important_plots[[disease]][["spatial.p.plot"]] <- p
important_plots[[disease]][["top.genetic.genes.df"]] <- top.genetic.genes
  
```

## liver_disease_general {.tabset}

subset features_to_plot to specific disease for now

```{r}
disease <- "liver_disease_general"

features_to_plot <- se[[]] %>%
  dplyr::select(contains("_rank_")) %>%
  colnames()
features_to_plot <- features_to_plot[features_to_plot %like% disease]
```

### Violin Plots

```{r , eval = violin}
<<Violin Plots>>
```

### grid.arrange FeaturePlot

```{r, fig.width=16, fig.height=12, eval = gridarrange}
<<featureplot>>
```

### line plots

```{r, fig.width = 5, fig.height= 10}

<<line plot>>
```

### p value permutation

#### top genetic genes

##### select top genes

```{r}
nr.top.genetic.windows <- 1 #or 8
#what was the window size:
win.size <- 50
move.by <- 10
nr.top.genes <- win.size + ((nr.top.genetic.windows-1) * move.by)
maximum <- ifelse(length(OT.files.split.genetic[[disease]])<=nr.top.genes,
                  length(OT.files.split.genetic[[disease]]),
                  nr.top.genes) %>% as.numeric()
top.genetic.genes <- OT.files.split.genetic[[disease]][1:maximum]
```

#### load correct null set for p-value calculation

==> number of genes per permutation should equal the number of top.genetic.genes (nr.top.genes)

```{r}
<<load_p_val_nullset>>
```

##### addmodulescore for top genes

```{r}
<<addmodulescore_top_genes>>
```

##### calculate p-value

```{r}
<<calculate p-value>>
```

### p-value density plot

```{r}
<<p-val-plot>>
```

purple line is the median addmodulescore of the top.genes in each cluster

### spatial p-val plot

```{r , fig.width=5, fig.height=4}
<<spatial_p_plot>>
```

## cirrhosis_of_liver {.tabset}
subset features_to_plot to specific disease for now
```{r}
disease <- "cirrhosis_of_liver"
features_to_plot <- se[[]] %>%
  dplyr::select(contains("_rank_")) %>%
  colnames()
features_to_plot <- features_to_plot[features_to_plot %like% disease]
```

### Violin Plots

```{r , eval = violin}
<<Violin Plots>>
```

### grid.arrange FeaturePlot

```{r, fig.width=16, fig.height=12, eval = gridarrange}
<<featureplot>>
```

### line plots

```{r, fig.width = 5, fig.height= 10}

<<line plot>>
```

### p value permutation

#### top genetic genes

##### select top genes

```{r}
nr.top.genetic.windows <- 10 #just all (100) # apparently don't have 100 gene permutation, use 80 as for familial cirrhosis
#what was the window size:
win.size <- 50
move.by <- 10
nr.top.genes <- win.size + ((nr.top.genetic.windows-1) * move.by)
# maximum <- ifelse(length(OT.files.split.genetic[[disease]])<=nr.top.genes,
#                   length(OT.files.split.genetic[[disease]]),
#                   nr.top.genes) %>% as.numeric() # 
maximum <- 80
top.genetic.genes <- OT.files.split.genetic[[disease]][1:maximum]
```

#### load correct null set for p-value calculation

==> number of genes per permutation should equal the number of top.genetic.genes (nr.top.genes)

```{r}
<<load_p_val_nullset>>
```

##### addmodulescore for top genes

```{r}
<<addmodulescore_top_genes>>
```

##### calculate p-value

```{r}
<<calculate p-value>>
```

### p-value density plot

```{r}
<<p-val-plot>>
```

purple line is the median addmodulescore of the top.genes in each cluster

### spatial p-val plot

```{r , fig.width=5, fig.height=4}
<<spatial_p_plot>>
```

## cirrhosis_familial {.tabset}
subset features_to_plot to specific disease for now
```{r}
disease <- "cirrhosis_familial"
features_to_plot <- se[[]] %>%
  dplyr::select(contains("_rank_")) %>%
  colnames()
features_to_plot <- features_to_plot[features_to_plot %like% disease]

```

### Violin Plots

```{r , eval = violin}
<<Violin Plots>>
```

### grid.arrange FeaturePlot

```{r, fig.width=16, fig.height=12, eval = gridarrange}
<<featureplot>>
```

### line plots

```{r, fig.width = 5, fig.height= 10}

<<line plot>>
```

### p value permutation

#### top genetic genes

##### select top genes

```{r}
nr.top.genetic.windows <- 8 #all 79
#what was the window size:
win.size <- 50
move.by <- 10
nr.top.genes <- win.size + ((nr.top.genetic.windows-1) * move.by)
maximum <- ifelse(length(OT.files.split.genetic[[disease]])<=nr.top.genes,
                  length(OT.files.split.genetic[[disease]]),
                  nr.top.genes) %>% as.numeric()
top.genetic.genes <- OT.files.split.genetic[[disease]][1:maximum]
```

#### load correct null set for p-value calculation

==> number of genes per permutation should equal the number of top.genetic.genes (nr.top.genes)

```{r}
<<load_p_val_nullset>>
```

##### addmodulescore for top genes

```{r}
<<addmodulescore_top_genes>>
```

##### calculate p-value

```{r}
<<calculate p-value>>
```

### p-value density plot

```{r}
<<p-val-plot>>
```

purple line is the median addmodulescore of the top.genes in each cluster

### spatial p-val plot

```{r , fig.width=5, fig.height=4}
<<spatial_p_plot>>
```

## Diabetes type I {.tabset}
subset features_to_plot to specific disease for now
```{r}
disease <- "Diabetes_typeI"
features_to_plot <- se[[]] %>%
  dplyr::select(contains("_rank_")) %>%
  colnames()

features_to_plot <- features_to_plot[features_to_plot %like% disease]
```

### Violin Plots

```{r , eval = violin}
<<Violin Plots>>
```

### grid.arrange FeaturePlot

```{r, fig.width=16, fig.height=12, eval = gridarrange}
<<featureplot>>
```

### line plots

```{r, fig.width = 5, fig.height= 10}

<<line plot>>
```

### p value permutation

#### top genetic genes

##### select top genes

```{r}
nr.top.genetic.windows <- 3
#what was the window size:
win.size <- 50
move.by <- 10
nr.top.genes <- win.size + ((nr.top.genetic.windows-1) * move.by)
maximum <- ifelse(length(OT.files.split.genetic[[disease]])<=nr.top.genes,
                  length(OT.files.split.genetic[[disease]]),
                  nr.top.genes) %>% as.numeric()
top.genetic.genes <- OT.files.split.genetic[[disease]][1:maximum]
```

#### load correct null set for p-value calculation

==> number of genes per permutation should equal the number of top.genetic.genes (nr.top.genes)

```{r}
<<load_p_val_nullset>>
```

##### addmodulescore for top genes

```{r}
<<addmodulescore_top_genes>>
```

##### calculate p-value

```{r}
<<calculate p-value>>
```

### p-value density plot

```{r}
<<p-val-plot>>
```

purple line is the median addmodulescore of the top.genes in each cluster

### spatial p-val plot

```{r , fig.width=5, fig.height=4}
<<spatial_p_plot>>
```

## Diabetes type II {.tabset}
subset features_to_plot to specific disease for now
```{r}
disease <- "diabetes_typeII"
features_to_plot <- se[[]] %>%
  dplyr::select(contains("_rank_")) %>%
  colnames()
features_to_plot <- features_to_plot[features_to_plot %like% disease]
```

### Violin Plots

```{r , eval = violin}
<<Violin Plots>>
```

### grid.arrange FeaturePlot

```{r, fig.width=16, fig.height=12, eval = gridarrange}
<<featureplot>>
```

### line plots

```{r, fig.width = 5, fig.height= 10}

<<line plot>>
```

### p value permutation

#### top genetic genes

##### select top genes

```{r}
nr.top.genetic.windows <- 3
#what was the window size:
win.size <- 50
move.by <- 10
nr.top.genes <- win.size + ((nr.top.genetic.windows-1) * move.by)
maximum <- ifelse(length(OT.files.split.genetic[[disease]])<=nr.top.genes,
                  length(OT.files.split.genetic[[disease]]),
                  nr.top.genes) %>% as.numeric()
top.genetic.genes <- OT.files.split.genetic[[disease]][1:maximum]
```

#### load correct null set for p-value calculation

==> number of genes per permutation should equal the number of top.genetic.genes (nr.top.genes)

```{r}
<<load_p_val_nullset>>
```

##### addmodulescore for top genes

```{r}
<<addmodulescore_top_genes>>
```

##### calculate p-value

```{r}
<<calculate p-value>>
```

### p-value density plot

```{r}
<<p-val-plot>>
```

purple line is the median addmodulescore of the top.genes in each cluster

### spatial p-val plot

```{r , fig.width=5, fig.height=4}
<<spatial_p_plot>>
```

## triglyceride_measurement {.tabset}
subset features_to_plot to specific disease for now
OBS ==> there is also LDL_triglyceride_measurement, so have to exclude that 
```{r}
disease <- "triglyceride_measurement"

`%notlike%` <- negate(`%like%`)
features_to_plot <- se[[]] %>%
  dplyr::select(contains("_rank_")) %>%
  colnames()
features_to_plot <- features_to_plot[features_to_plot %like% disease]
features_to_plot <- features_to_plot[features_to_plot %notlike% "LDL"]
```

### Violin Plots

```{r , eval = violin}
<<Violin Plots>>
```

### grid.arrange FeaturePlot

```{r, fig.width=16, fig.height=12, eval = gridarrange}
<<featureplot>>
```

### line plots

```{r, fig.width = 5, fig.height= 10}

<<line plot>>
```

### p value permutation

#### top genetic genes

##### select top genes

```{r}
nr.top.genetic.windows <- 2 #60
#what was the window size:
win.size <- 50
move.by <- 10
nr.top.genes <- win.size + ((nr.top.genetic.windows-1) * move.by)
maximum <- ifelse(length(OT.files.split.genetic[[disease]])<=nr.top.genes,
                  length(OT.files.split.genetic[[disease]]),
                  nr.top.genes) %>% as.numeric()
top.genetic.genes <- OT.files.split.genetic[[disease]][1:maximum]
```

#### load correct null set for p-value calculation

==> number of genes per permutation should equal the number of top.genetic.genes (nr.top.genes)

```{r}
<<load_p_val_nullset>>
```

##### addmodulescore for top genes

```{r}
<<addmodulescore_top_genes>>
```

##### calculate p-value

```{r}
<<calculate p-value>>
```

### p-value density plot

```{r}
<<p-val-plot>>
```

purple line is the median addmodulescore of the top.genes in each cluster

### spatial p-val plot

```{r , fig.width=5, fig.height=4}
<<spatial_p_plot>>
```

## LDL_triglyceride_measurement {.tabset}
subset features_to_plot to specific disease for now
```{r}
disease <- "LDL_triglyceride_measurement"

features_to_plot <- se[[]] %>%
  dplyr::select(contains("_rank_")) %>%
  colnames()
features_to_plot <- features_to_plot[features_to_plot %like% disease]
```

### Violin Plots

```{r , eval = violin}
<<Violin Plots>>
```

### grid.arrange FeaturePlot

```{r, fig.width=16, fig.height=12, eval = gridarrange}
<<featureplot>>
```

### line plots

```{r, fig.width = 5, fig.height= 10}

<<line plot>>
```

### p value permutation

#### top genetic genes

##### select top genes

```{r}
nr.top.genetic.windows <- 1 # was a bit weird/hard to tell
#what was the window size:
win.size <- 50
move.by <- 10
nr.top.genes <- win.size + ((nr.top.genetic.windows-1) * move.by)
maximum <- ifelse(length(OT.files.split.genetic[[disease]])<=nr.top.genes,
                  length(OT.files.split.genetic[[disease]]),
                  nr.top.genes) %>% as.numeric()
top.genetic.genes <- OT.files.split.genetic[[disease]][1:maximum]
```

#### load correct null set for p-value calculation

==> number of genes per permutation should equal the number of top.genetic.genes (nr.top.genes)

```{r}
<<load_p_val_nullset>>
```

##### addmodulescore for top genes

```{r}
<<addmodulescore_top_genes>>
```

##### calculate p-value

```{r}
<<calculate p-value>>
```

### p-value density plot

```{r}
<<p-val-plot>>
```

purple line is the median addmodulescore of the top.genes in each cluster

### spatial p-val plot

```{r , fig.width=5, fig.height=4}
<<spatial_p_plot>>
```

## cholesterol_measurement {.tabset}
subset features_to_plot to specific disease for now
```{r}
disease <- "cholesterol_measurement"

features_to_plot <- se[[]] %>%
  dplyr::select(contains("_rank_")) %>%
  colnames()
features_to_plot <- features_to_plot[features_to_plot %like% disease]
features_to_plot <- features_to_plot[features_to_plot %notlike% "LDL"]
features_to_plot <- features_to_plot[features_to_plot %notlike% "HDL"]

```

### Violin Plots

```{r , eval = violin}
<<Violin Plots>>
```

### grid.arrange FeaturePlot

```{r, fig.width=16, fig.height=12, eval = gridarrange}
<<featureplot>>
```

### line plots

```{r, fig.width = 5, fig.height= 10}

<<line plot>>
```

### p value permutation

#### top genetic genes

##### select top genes

```{r}
nr.top.genetic.windows <- 9
#what was the window size:
win.size <- 50
move.by <- 10
nr.top.genes <- win.size + ((nr.top.genetic.windows-1) * move.by)
maximum <- ifelse(length(OT.files.split.genetic[[disease]])<=nr.top.genes,
                  length(OT.files.split.genetic[[disease]]),
                  nr.top.genes) %>% as.numeric()
top.genetic.genes <- OT.files.split.genetic[[disease]][1:maximum]
```

#### load correct null set for p-value calculation

==> number of genes per permutation should equal the number of top.genetic.genes (nr.top.genes)

```{r}
<<load_p_val_nullset>>
```

##### addmodulescore for top genes

```{r}
<<addmodulescore_top_genes>>
```

##### calculate p-value

```{r}
<<calculate p-value>>
```

### p-value density plot

```{r}
<<p-val-plot>>
```

purple line is the median addmodulescore of the top.genes in each cluster

### spatial p-val plot

```{r , fig.width=5, fig.height=4}
<<spatial_p_plot>>
```

## LDL_cholesterol_measurement {.tabset}
subset features_to_plot to specific disease for now
```{r}
disease <- "LDL_cholesterol_measurement"

features_to_plot <- se[[]] %>%
  dplyr::select(contains("_rank_")) %>%
  colnames()
features_to_plot <- features_to_plot[features_to_plot %like% disease]
```

### Violin Plots

```{r , eval = violin}
<<Violin Plots>>
```

### grid.arrange FeaturePlot

```{r, fig.width=16, fig.height=12, eval = gridarrange}
<<featureplot>>
```

### line plots

```{r, fig.width = 5, fig.height= 10}

<<line plot>>
```

### p value permutation

#### top genetic genes

##### select top genes

```{r}
nr.top.genetic.windows <- 13 #or 13
#what was the window size:
win.size <- 50
move.by <- 10
nr.top.genes <- win.size + ((nr.top.genetic.windows-1) * move.by)
maximum <- ifelse(length(OT.files.split.genetic[[disease]])<=nr.top.genes,
                  length(OT.files.split.genetic[[disease]]),
                  nr.top.genes) %>% as.numeric()
top.genetic.genes <- OT.files.split.genetic[[disease]][1:maximum]
```

#### load correct null set for p-value calculation

==> number of genes per permutation should equal the number of top.genetic.genes (nr.top.genes)

```{r}
<<load_p_val_nullset>>
```

##### addmodulescore for top genes

```{r}
<<addmodulescore_top_genes>>
```

##### calculate p-value

```{r}
<<calculate p-value>>
```

### p-value density plot

```{r}
<<p-val-plot>>
```

purple line is the median addmodulescore of the top.genes in each cluster

### spatial p-val plot

```{r , fig.width=5, fig.height=4}
<<spatial_p_plot>>
```


## HDL_cholesterol_measurement {.tabset}
should be HDL_cholesterol
subset features_to_plot to specific disease for now
```{r, }
disease <- "HDL_cholesterol_measurement"

features_to_plot <- se[[]] %>%
  dplyr::select(contains("_rank_")) %>%
  colnames()
features_to_plot <- features_to_plot[features_to_plot %like% disease]
```

### Violin Plots

```{r , eval = violin}
<<Violin Plots>>
```

### grid.arrange FeaturePlot

```{r, fig.width=16, fig.height=12, eval = gridarrange}
<<featureplot>>
```

### line plots

```{r, fig.width = 5, fig.height= 10}

<<line plot>>
```

### p value permutation

#### top genetic genes

##### select top genes

```{r}
nr.top.genetic.windows <- 1
#what was the window size:
win.size <- 50
move.by <- 10
nr.top.genes <- win.size + ((nr.top.genetic.windows-1) * move.by)
maximum <- ifelse(length(OT.files.split.genetic[[disease]])<=nr.top.genes,
                  length(OT.files.split.genetic[[disease]]),
                  nr.top.genes) %>% as.numeric()
top.genetic.genes <- OT.files.split.genetic[[disease]][1:maximum]
```

#### load correct null set for p-value calculation

==> number of genes per permutation should equal the number of top.genetic.genes (nr.top.genes)

```{r}
<<load_p_val_nullset>>
```

##### addmodulescore for top genes

```{r}
<<addmodulescore_top_genes>>
```

##### calculate p-value

```{r}
<<calculate p-value>>
```

### p-value density plot

```{r}
<<p-val-plot>>
```

purple line is the median addmodulescore of the top.genes in each cluster

### spatial p-val plot

```{r , fig.width=5, fig.height=4}
<<spatial_p_plot>>
```


# save important plots
```{r}
object.size(important_plots)
length(important_plots)
names(important_plots)
important_plots[["NAFLD"]]
saveRDS(important_plots,
        file = paste0(sample.path, "/important_plots_", sample,".rds"))
```